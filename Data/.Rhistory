}
ARMAauto <- function(phi,theta,maxlag)
{
p <- length(phi)
q <- length(theta)
gamMA <- polymul(c(1,theta),rev(c(1,theta)))
gamMA <- gamMA[(q+1):(2*q+1)]
if (p > 0)
{
Amat <- matrix(0,nrow=(p+1),ncol=(2*p+1))
for(i in 1:(p+1))
{
Amat[i,i:(i+p)] <- c(-1*rev(phi),1)
}
Amat <- cbind(Amat[,(p+1)],as.matrix(Amat[,(p+2):(2*p+1)]) +
t(matrix(apply(t(matrix(Amat[,1:p],p+1,p)),2,rev),p,p+1)))
Bmat <- matrix(0,nrow=(q+1),ncol=(p+q+1))
for(i in 1:(q+1))
{
Bmat[i,i:(i+p)] <- c(-1*rev(phi),1)
}
Bmat <- t(matrix(apply(t(Bmat),2,rev),p+q+1,q+1))
Bmat <- matrix(apply(Bmat,2,rev),q+1,p+q+1)
Bmat <- Bmat[,1:(q+1)]
Binv <- solve(Bmat)
gamMix <- Binv %*% gamMA
if (p <= q) { gamMix <- matrix(gamMix[1:(p+1),],p+1,1)
} else gamMix <- matrix(c(gamMix,rep(0,(p-q))),p+1,1)
gamARMA <- solve(Amat) %*% gamMix
} else gamARMA <- gamMA[1]
gamMA <- as.vector(gamMA)
if (maxlag <= q) gamMA <- gamMA[1:(maxlag+1)] else gamMA <- c(gamMA,rep(0,(maxlag-q)))
gamARMA <- as.vector(gamARMA)
if (maxlag <= p) gamARMA <- gamARMA[1:(maxlag+1)] else {
for(k in 1:(maxlag-p))
{
len <- length(gamARMA)
acf <- gamMA[p+1+k]
if (p > 0) acf <- acf + sum(phi*rev(gamARMA[(len-p+1):len]))
gamARMA <- c(gamARMA,acf)
} }
return(gamARMA)
}
Wstarts <- read.table("Wstarts.b1",header=TRUE,skip=2)[,2]
Wstarts <- ts(Wstarts,start = 1964,frequency=12)
west <- diff(log(Wstarts),lag=12)
n <- length(west)
gamma.hat <- acf(west,lag=n-1,type="covariance")$acf[,,1]
q <- 12
gausslik.maq <- function(theta,data,fit.flag)
{
n <- length(data)
gamma.maq <- ARMAauto(NULL,theta,n)
kappa.vec <- gamma.maq[2]/gamma.maq[1]
varphi.vec <- kappa.vec
quad.new <- 0
quads <- NULL
ldet <- 0
ldets <- NULL
eps <- NULL
for(k in 2:n)
{
schur.new <- gamma.maq[1] - t(varphi.vec) %*% rev(gamma.maq[2:k])
eps.new <- data[k] - t(varphi.vec) %*% data[1:(k-1)]
eps <- c(eps,eps.new)
quad.new <- quad.new + eps.new^2/schur.new
quads <- c(quads,quad.new)
ldet <- ldet + log(schur.new)
ldets <- c(ldets,ldet)
kappa.new <- (gamma.maq[k+1] - sum(varphi.vec*gamma.maq[2:k]))/schur.new
kappa.new <- kappa.new[1,1]
if(abs(kappa.new) < 10^(-15)) kappa.new <- 0
kappa.vec <- c(kappa.vec,kappa.new)
varphi.vec <- rev(varphi.vec) - kappa.new * varphi.vec
varphi.vec <- rev(c(varphi.vec,kappa.new))
}
gauss.lik <- n*(1 + log(2*pi)) + n*log(quads[n-1]/n) + ldets[n-1]
if(fit.flag) { return(gauss.lik) } else
{
return(list(quads[n-1]/n,eps))
}
}
## initial spectral factorization fit
lambda <- seq(-n/2+1,n/2)*2*pi/n
pgram.q <- cos(0*lambda)*gamma.hat[1]
for(h in 1:q)
{
pgram.q <- pgram.q + 2*cos(h*lambda)*gamma.hat[h+1]
}
pgram.q <- ts(pgram.q,start=0,frequency=n)
min.q <- min(pgram.q)
acf.q <- c(gamma.hat[1]-min.q,gamma.hat[2:(q+1)])
t <- 200
gamma.mat <- toeplitz(c(acf.q,rep(0,t-length(acf.q))))
l.mat <- t(chol(gamma.mat))
theta.sf <- rev(l.mat[dim(l.mat)[1],])[1:(q+1)]
sig.var <- theta.sf[1]^2
theta.sf <- theta.sf[-1]/theta.sf[1]
## fit using MLE
fit.maq <- optim(theta.sf,gausslik.maq,data=west,fit.flag=TRUE,method="BFGS")
#theta.init <- rep(0,q)
#fit.maq <- optim(theta.init,gausslik.maq,data=west,fit.flag=TRUE,method="BFGS")
theta.mle <- fit.maq$par
sig2.mle <- gausslik.maq(theta.mle,west,fit.flag=FALSE)[[1]]
resid.mle <- gausslik.maq(theta.mle,west,fit.flag=FALSE)[[2]]
acf(resid.mle)
theta.sf
theta.mle
dput(theta.mle)
dput(sig2.mle)
knitr::opts_knit$set(root.dir = '/home/tucker/Documents/GitHub/BEwebinar/Data')
polymul <- function(a,b)
{
bb <- c(b,rep(0,length(a)-1))
B <- toeplitz(bb)
B[lower.tri(B)] <- 0
aa <- rev(c(a,rep(0,length(b)-1)))
prod <- B %*% matrix(aa,length(aa),1)
return(rev(prod[,1]))
}
ARMAauto <- function(phi,theta,maxlag)
{
p <- length(phi)
q <- length(theta)
gamMA <- polymul(c(1,theta),rev(c(1,theta)))
gamMA <- gamMA[(q+1):(2*q+1)]
if (p > 0)
{
Amat <- matrix(0,nrow=(p+1),ncol=(2*p+1))
for(i in 1:(p+1))
{
Amat[i,i:(i+p)] <- c(-1*rev(phi),1)
}
Amat <- cbind(Amat[,(p+1)],as.matrix(Amat[,(p+2):(2*p+1)]) +
t(matrix(apply(t(matrix(Amat[,1:p],p+1,p)),2,rev),p,p+1)))
Bmat <- matrix(0,nrow=(q+1),ncol=(p+q+1))
for(i in 1:(q+1))
{
Bmat[i,i:(i+p)] <- c(-1*rev(phi),1)
}
Bmat <- t(matrix(apply(t(Bmat),2,rev),p+q+1,q+1))
Bmat <- matrix(apply(Bmat,2,rev),q+1,p+q+1)
Bmat <- Bmat[,1:(q+1)]
Binv <- solve(Bmat)
gamMix <- Binv %*% gamMA
if (p <= q) { gamMix <- matrix(gamMix[1:(p+1),],p+1,1)
} else gamMix <- matrix(c(gamMix,rep(0,(p-q))),p+1,1)
gamARMA <- solve(Amat) %*% gamMix
} else gamARMA <- gamMA[1]
gamMA <- as.vector(gamMA)
if (maxlag <= q) gamMA <- gamMA[1:(maxlag+1)] else gamMA <- c(gamMA,rep(0,(maxlag-q)))
gamARMA <- as.vector(gamARMA)
if (maxlag <= p) gamARMA <- gamARMA[1:(maxlag+1)] else {
for(k in 1:(maxlag-p))
{
len <- length(gamARMA)
acf <- gamMA[p+1+k]
if (p > 0) acf <- acf + sum(phi*rev(gamARMA[(len-p+1):len]))
gamARMA <- c(gamARMA,acf)
} }
return(gamARMA)
}
Wstarts <- read.table("Wstarts.b1",header=TRUE,skip=2)[,2]
Wstarts <- ts(Wstarts,start = 1964,frequency=12)
west <- diff(log(Wstarts),lag=12)
n <- length(west)
gamma.hat <- acf(west,lag=n-1,type="covariance",plot=FALSE)$acf[,,1]
q <- 12
gausslik.maq <- function(theta,data,fit.flag)
{
n <- length(data)
gamma.maq <- ARMAauto(NULL,theta,n)
kappa.vec <- gamma.maq[2]/gamma.maq[1]
varphi.vec <- kappa.vec
quad.new <- 0
quads <- NULL
ldet <- 0
ldets <- NULL
eps <- NULL
for(k in 2:n)
{
schur.new <- gamma.maq[1] - t(varphi.vec) %*% rev(gamma.maq[2:k])
eps.new <- data[k] - t(varphi.vec) %*% data[1:(k-1)]
eps <- c(eps,eps.new)
quad.new <- quad.new + eps.new^2/schur.new
quads <- c(quads,quad.new)
ldet <- ldet + log(schur.new)
ldets <- c(ldets,ldet)
kappa.new <- (gamma.maq[k+1] - sum(varphi.vec*gamma.maq[2:k]))/schur.new
kappa.new <- kappa.new[1,1]
if(abs(kappa.new) < 10^(-15)) kappa.new <- 0
kappa.vec <- c(kappa.vec,kappa.new)
varphi.vec <- rev(varphi.vec) - kappa.new * varphi.vec
varphi.vec <- rev(c(varphi.vec,kappa.new))
}
gauss.lik <- n*(1 + log(2*pi)) + n*log(quads[n-1]/n) + ldets[n-1]
if(fit.flag) { return(gauss.lik) } else
{
return(list(quads[n-1]/n,eps))
}
}
theta.mle <- c(0.651972958905815, 0.652200820985369, 0.627422633499361, 0.646525805480097,
0.625424457604761, 0.644635978951906, 0.637430978594635, 0.635720014729216,
0.625268961947794, 0.634947219500035, 0.600750521900405, -0.367624464655481
)
sig2.mle <- gausslik.maq(theta.mle,west,fit.flag=FALSE)[[1]]
resid.mle <- gausslik.maq(theta.mle,west,fit.flag=FALSE)[[2]]
acf(resid.mle)
theta.poly <- c(1,theta.mle)
new.poly <- 1
sig2.new <- sig2.mle
ma.roots <- polyroot(theta.poly)
for(i in 1:q)
{
if(Mod(ma.roots[i]) < 1)
{
ma.roots[i] <- 1/ma.roots[i]
sig2.new <- sig2.new*(1/ma.roots[i]^2)
}
new.poly <- polymul(new.poly,c(1,-1/ma.roots[i]))
}
new.poly <- Re(new.poly)
sig2.new <- Re(sig2.new)
theta.inv <- new.poly[-1]
H <- 100
T <- n+2*H
gamma <- ARMAauto(NULL,theta.inv,T)*sig2.new
x <- c(rep(NA,H),west,rep(NA,H))
plot(ts(x),lty=1,ylab="")
x.fore <- c(west,rep(NA,H))
T <- n+H
kappa.vec <- gamma[2]/gamma[1]
varphi.vec <- kappa.vec
for(k in 2:(T-1))
{
schur.new <- gamma[1] - t(varphi.vec) %*% rev(gamma[2:k])
kappa.new <- (gamma[k+1] - sum(varphi.vec*gamma[2:k]))/schur.new
kappa.new <- kappa.new[1,1]
if(abs(kappa.new) < 10^(-15)) kappa.new <- 0
kappa.vec <- c(kappa.vec,kappa.new)
varphi.vec <- rev(varphi.vec) - kappa.new * varphi.vec
varphi.vec <- rev(c(varphi.vec,kappa.new))
cast <- sum(varphi.vec * x.fore[1:k])
if(k >= n) x.fore[k+1] <- cast
}
x.aft <- rev(c(rep(NA,H),x.fore))
T <- n+2*H
kappa.vec <- gamma[2]/gamma[1]
varphi.vec <- kappa.vec
for(k in 2:(T-1))
{
schur.new <- gamma[1] - t(varphi.vec) %*% rev(gamma[2:k])
kappa.new <- (gamma[k+1] - sum(varphi.vec*gamma[2:k]))/schur.new
kappa.new <- kappa.new[1,1]
if(abs(kappa.new) < 10^(-15)) kappa.new <- 0
kappa.vec <- c(kappa.vec,kappa.new)
varphi.vec <- rev(varphi.vec) - kappa.new * varphi.vec
varphi.vec <- rev(c(varphi.vec,kappa.new))
cast <- sum(varphi.vec * x.aft[1:k])
if(k >= n+H) x.aft[k+1] <- cast
}
x.cast <- rev(x.aft)
x.ext <- ts(x.cast,start=(1964-H/12),frequency=12)
H <- 100
T <- n+2*H
gamma <- ARMAauto(NULL,theta.inv,T)*sig2.new
x <- c(rep(NA,H),west,rep(NA,H))
x.fore <- c(west,rep(NA,H))
T <- n+H
kappa.vec <- gamma[2]/gamma[1]
varphi.vec <- kappa.vec
for(k in 2:(T-1))
{
schur.new <- gamma[1] - t(varphi.vec) %*% rev(gamma[2:k])
kappa.new <- (gamma[k+1] - sum(varphi.vec*gamma[2:k]))/schur.new
kappa.new <- kappa.new[1,1]
if(abs(kappa.new) < 10^(-15)) kappa.new <- 0
kappa.vec <- c(kappa.vec,kappa.new)
varphi.vec <- rev(varphi.vec) - kappa.new * varphi.vec
varphi.vec <- rev(c(varphi.vec,kappa.new))
cast <- sum(varphi.vec * x.fore[1:k])
if(k >= n) x.fore[k+1] <- cast
}
x.aft <- rev(c(rep(NA,H),x.fore))
T <- n+2*H
kappa.vec <- gamma[2]/gamma[1]
varphi.vec <- kappa.vec
for(k in 2:(T-1))
{
schur.new <- gamma[1] - t(varphi.vec) %*% rev(gamma[2:k])
kappa.new <- (gamma[k+1] - sum(varphi.vec*gamma[2:k]))/schur.new
kappa.new <- kappa.new[1,1]
if(abs(kappa.new) < 10^(-15)) kappa.new <- 0
kappa.vec <- c(kappa.vec,kappa.new)
varphi.vec <- rev(varphi.vec) - kappa.new * varphi.vec
varphi.vec <- rev(c(varphi.vec,kappa.new))
cast <- sum(varphi.vec * x.aft[1:k])
if(k >= n+H) x.aft[k+1] <- cast
}
x.cast <- rev(x.aft)
x.ext <- ts(x.cast,start=(1964-H/12),frequency=12)
plot(ts(x),lty=1,ylab="")
lines(x.ext,col=2)
H <- 100
T <- n+2*H
gamma <- ARMAauto(NULL,theta.inv,T)*sig2.new
x <- c(rep(NA,H),west,rep(NA,H))
x.fore <- c(west,rep(NA,H))
T <- n+H
kappa.vec <- gamma[2]/gamma[1]
varphi.vec <- kappa.vec
for(k in 2:(T-1))
{
schur.new <- gamma[1] - t(varphi.vec) %*% rev(gamma[2:k])
kappa.new <- (gamma[k+1] - sum(varphi.vec*gamma[2:k]))/schur.new
kappa.new <- kappa.new[1,1]
if(abs(kappa.new) < 10^(-15)) kappa.new <- 0
kappa.vec <- c(kappa.vec,kappa.new)
varphi.vec <- rev(varphi.vec) - kappa.new * varphi.vec
varphi.vec <- rev(c(varphi.vec,kappa.new))
cast <- sum(varphi.vec * x.fore[1:k])
if(k >= n) x.fore[k+1] <- cast
}
x.aft <- rev(c(rep(NA,H),x.fore))
T <- n+2*H
kappa.vec <- gamma[2]/gamma[1]
varphi.vec <- kappa.vec
for(k in 2:(T-1))
{
schur.new <- gamma[1] - t(varphi.vec) %*% rev(gamma[2:k])
kappa.new <- (gamma[k+1] - sum(varphi.vec*gamma[2:k]))/schur.new
kappa.new <- kappa.new[1,1]
if(abs(kappa.new) < 10^(-15)) kappa.new <- 0
kappa.vec <- c(kappa.vec,kappa.new)
varphi.vec <- rev(varphi.vec) - kappa.new * varphi.vec
varphi.vec <- rev(c(varphi.vec,kappa.new))
cast <- sum(varphi.vec * x.aft[1:k])
if(k >= n+H) x.aft[k+1] <- cast
}
x.cast <- rev(x.aft)
x.ext <- ts(x.cast,start=(1964-H/12),frequency=12)
plot(ts(x,start=(1964-H/12),frequency=12),lty=1,ylab="")
lines(x.ext,col=2)
H <- 100
T <- n+2*H
gamma <- ARMAauto(NULL,theta.inv,T)*sig2.new
x <- c(rep(NA,H),west,rep(NA,H))
x.fore <- c(west,rep(NA,H))
T <- n+H
kappa.vec <- gamma[2]/gamma[1]
varphi.vec <- kappa.vec
for(k in 2:(T-1))
{
schur.new <- gamma[1] - t(varphi.vec) %*% rev(gamma[2:k])
kappa.new <- (gamma[k+1] - sum(varphi.vec*gamma[2:k]))/schur.new
kappa.new <- kappa.new[1,1]
if(abs(kappa.new) < 10^(-15)) kappa.new <- 0
kappa.vec <- c(kappa.vec,kappa.new)
varphi.vec <- rev(varphi.vec) - kappa.new * varphi.vec
varphi.vec <- rev(c(varphi.vec,kappa.new))
cast <- sum(varphi.vec * x.fore[1:k])
if(k >= n) x.fore[k+1] <- cast
}
x.aft <- rev(c(rep(NA,H),x.fore))
T <- n+2*H
kappa.vec <- gamma[2]/gamma[1]
varphi.vec <- kappa.vec
for(k in 2:(T-1))
{
schur.new <- gamma[1] - t(varphi.vec) %*% rev(gamma[2:k])
kappa.new <- (gamma[k+1] - sum(varphi.vec*gamma[2:k]))/schur.new
kappa.new <- kappa.new[1,1]
if(abs(kappa.new) < 10^(-15)) kappa.new <- 0
kappa.vec <- c(kappa.vec,kappa.new)
varphi.vec <- rev(varphi.vec) - kappa.new * varphi.vec
varphi.vec <- rev(c(varphi.vec,kappa.new))
cast <- sum(varphi.vec * x.aft[1:k])
if(k >= n+H) x.aft[k+1] <- cast
}
x.cast <- rev(x.aft)
x.ext <- ts(x.cast,start=(1964-H/12),frequency=12)
plot(x.ext,col=2,ylab="",xlab="Year")
lines(ts(x,start=(1964-H/12),frequency=12))
dow <- read.table("dow.dat")
knitr::opts_knit$set(root.dir = '/home/tucker/Documents/GitHub/BEwebinar/Data')
dow <- read.table("dow.dat")
dow <- diff(log(dow[,1]))
dow <- ts(dow,start=c(2008,164),frequency=252)
knitr::opts_knit$set(root.dir = '/home/tucker/Documents/GitHub/BEwebinar/Data')
dow <- read.table("dow.dat")
dow <- diff(log(dow[,1]))
dow <- ts(dow,start=c(2008,164),frequency=252)
polymul <- function(a,b)
{
bb <- c(b,rep(0,length(a)-1))
B <- toeplitz(bb)
B[lower.tri(B)] <- 0
aa <- rev(c(a,rep(0,length(b)-1)))
prod <- B %*% matrix(aa,length(aa),1)
return(rev(prod[,1]))
}
psi2arch <- function(psi)
{
p <- length(psi)-1
a.0 <- exp(psi[1])
if(p > 0)
{
r <- (1 + exp(-psi[2]))^(-1)
if(p > 1)
{
a.1 <- (1 + sum(exp(-psi[3:(p+1)])))^(-1)
a.j <- a.1
for(j in 2:p)
{
a.j <- c(a.j,exp(-psi[j+1])*a.1)
}
a.j <- r*a.j
} else { a.j <- r }
a.0 <- c(a.0,a.j)
}
return(a.0)
}
lik.garch <- function(psi,data,p.order,df,fitting=TRUE)
{
p <- p.order
q <- length(psi)-p-1
T <- length(data)
coef <- psi2arch(psi)
acoef <- coef[1:(p+1)]
bcoef <- NULL
if(q > 0) { bcoef <- coef[(p+2):(p+q+1)] }
theta <- bcoef
phi <- acoef[-1]
psi <- c(1,ARMAtoMA(ar=theta,ma=NULL,lag.max=T))
psi <- polymul(psi,phi)
lik <- 0
resids <- NULL
for(t in (p+1):T)
{
new.sigt <- sqrt(acoef[1]/(1-sum(theta)) + sum(psi[1:(t-1)]*data[(t-1):1]^2))
if(df==Inf) { lik <- lik + (-2)*log(dnorm(data[t],sd=new.sigt)) } else {
lik <- lik + (-2)*log(dt(data[t]/new.sigt,df=df)/new.sigt) }
resids <- c(resids,data[t]/new.sigt)
}
if(fitting) { return(lik) } else { return(resids) }
}
wolfer <- read.table("wolfer.dat")
knitr::opts_knit$set(root.dir = '/home/tucker/Documents/GitHub/BEwebinar/Data')
wolfer <- read.table("wolfer.dat")
wolfer <- read.table("wolfer.dat")
wolfer <- ts(wolfer,start=1749,frequency=12)
n <- length(wolfer)
gamma.hat <- acf(wolfer,lag=n-1,type="covariance",plot=FALSE)$acf[,,1]
lambda <- seq(-floor(n/2)+1,floor(n/2))*2*pi/n
Q.mat <- exp(1i*seq(-floor(n/2)+1,floor(n/2)) %x% t(lambda))/sqrt(n)
wolfer.dft <- Conj(Q.mat) %*% (wolfer-mean(wolfer))
wolfer.pgram <- Mod(wolfer.dft)^2
wolfer <- read.table("wolfer.dat")
wolfer <- ts(wolfer,start=1749,frequency=12)
n <- length(wolfer)
gamma.hat <- acf(wolfer,lag=n-1,type="covariance",plot=FALSE)$acf[,,1]
lambda <- seq(-floor(n/2)+1,floor(n/2))*2*pi/n
Q.mat <- exp(1i*seq(-floor(n/2)+1,floor(n/2)) %x% t(lambda))/sqrt(n)
wolfer.dft <- Conj(Q.mat) %*% (wolfer-mean(wolfer))
wolfer.pgram <- Mod(wolfer.dft)^2
d <- 3*floor(n^{1/3})
wolfer.spec <- cos(0*lambda)*gamma.hat[1]
for(h in 1:(n-1))
{
wolfer.spec <- wolfer.spec + 2*(max(1-h/d,0))*cos(h*lambda)*gamma.hat[h+1]
}
wolfer.spec <- ts(wolfer.spec[-1],start=0,frequency=grid)
setwd('/home/tucker/Documents/GitHub/BEwebinar/Data')
wolfer <- read.table("wolfer.dat")
wolfer <- ts(wolfer,start=1749,frequency=12)
n <- length(wolfer)
gamma.hat <- acf(wolfer,lag=n-1,type="covariance",plot=FALSE)$acf[,,1]
lambda <- seq(-floor(n/2)+1,floor(n/2))*2*pi/n
Q.mat <- exp(1i*seq(-floor(n/2)+1,floor(n/2)) %x% t(lambda))/sqrt(n)
wolfer.pgram <- Mod(wolfer.dft)^2
d <- 3*floor(n^{1/3})
wolfer.spec <- cos(0*lambda)*gamma.hat[1]
for(h in 1:(n-1))
{
wolfer.spec <- wolfer.spec + 2*(max(1-h/d,0))*cos(h*lambda)*gamma.hat[h+1]
}
wolfer.spec <- ts(wolfer.spec[-1],start=0,frequency=grid)
wolfer.spec
min(wolfer.spec)
wolfer.spec[-1]
wolfer.spec <- ts(wolfer.spec[-1],start=0,frequency=n)
Lambda.factor <- diag(1/sqrt(wolfer.spec))
#Lambda.mat <- diag(wolfer.spec)
wolfer.sieved <- Lambda.factor %*% wolfer.dft
wolfer.sieved <- wolfer.dft/sqrt(wolfer.spec)
length(wolfer.spec)
wolfer.spec <- cos(0*lambda)*gamma.hat[1]
for(h in 1:(n-1))
{
wolfer.spec <- wolfer.spec + 2*(max(1-h/d,0))*cos(h*lambda)*gamma.hat[h+1]
}
wolfer.spec[1]
d <- 3*floor(n^{1/3})
wolfer.spec <- cos(0*lambda)*gamma.hat[1]
for(h in 1:(n-1))
{
wolfer.spec <- wolfer.spec + 2*(max(1-h/d,0))*cos(h*lambda)*gamma.hat[h+1]
}
wolfer.sieved <- wolfer.dft/sqrt(wolfer.spec)
wolfer.resids <- Re(Q.mat %*% wolfer.sieved)
gamma.resids <- acf(wolfer.resids,lag=n-1,type="covariance")$acf[,,1]
gamma.resids <- acf(wolfer.resids,lag=n-1,type="correlation")$acf[,,1]
